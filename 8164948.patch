From d0c532d9b3e657fea7ce93602553c9d74aab85a6 Mon Sep 17 00:00:00 2001
Date: Fri, 21 Jun 2019 14:21:55 +0000
Subject: [PATCH] 8164948: Initializing stores of HeapRegions are not ordered with regards to their use in G1ConcurrentMark

Summary: Initializing stores of HeapRegions are not ordered with regards to their use in G1ConcurrentMark
LLT:
bug link: https://bugs.openjdk.java.net/browse/JDK-8164948
---
 hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp    | 2 ++
 hotspot/src/share/vm/gc_implementation/g1/heapRegionManager.cpp | 1 +
 2 files changed, 3 insertions(+)

diff --git a/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp b/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp
index ea0e564b73..0c12478f2f 100644
--- a/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp
+++ b/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp
@@ -3006,6 +3006,8 @@ ConcurrentMark::claim_region(uint worker_id) {
     // iterations) but it should not introduce and correctness issues.
     HeapRegion* curr_region = _g1h->heap_region_containing_raw(finger);
 
+    // Make sure that the reads below do not float before loading curr_region.
+    OrderAccess::loadload();
     // Above heap_region_containing_raw may return NULL as we always scan claim
     // until the end of the heap. In this case, just jump to the next region.
     HeapWord* end = curr_region != NULL ? curr_region->end() : finger + HeapRegion::GrainWords;
diff --git a/hotspot/src/share/vm/gc_implementation/g1/heapRegionManager.cpp b/hotspot/src/share/vm/gc_implementation/g1/heapRegionManager.cpp
index 14673df747..49c231d89b 100644
--- a/hotspot/src/share/vm/gc_implementation/g1/heapRegionManager.cpp
+++ b/hotspot/src/share/vm/gc_implementation/g1/heapRegionManager.cpp
@@ -124,6 +124,7 @@ void HeapRegionManager::make_regions_available(uint start, uint num_regions) {
   for (uint i = start; i < start + num_regions; i++) {
     if (_regions.get_by_index(i) == NULL) {
       HeapRegion* new_hr = new_heap_region(i);
+      OrderAccess::storestore();
       _regions.set_by_index(i, new_hr);
       _allocated_heapregions_length = MAX2(_allocated_heapregions_length, i + 1);
     }
-- 
2.12.3

